# BOJ 11652 - 카드

## REQ
- (1) N의 값을 입력받고, N개의 정수를 입력받는다
- (2) N개의 수중 가장 많은 수를 출력한다.
-  N (1 ≤ N ≤ 100,000)
- 262보다 크거나 같고, 262보다 작거나 같다. 입력 정수
- 출력: 가장 많이 가지고 있는 정수 출력

## DS
- vector<Person> (age, name)

## Algo
- 입력받은 수를 크기순으로 나열한다.
    - 같은 수의 경우 입력받은 순서로 나열한다.
- 하나씩 읽었을때 같은수의 경우 cnt를 증가시키고, 전과 다른수가 나오면 cnt값을 previous_value[]에 stable_sort한 배열 값과 함께 저장하고 cnt를 0으로 초기화한다. 그후 다시 카운트를 시작하고 다른 수가 나오는 순간 그때cnt값이 previous_value보다 크면 업데이트하고 아니면 0으로 초기화한다.

## Complexity
- Time: O(N log N)
- Mem: O(N)
1) 입력 읽기 + 벡터에 저장

N개를 한 번씩 읽고 push_back

각 원소 처리 비용은 상수 시간이라고 보고
→ O(N)

2) 정렬

sort(v.begin(), v.end())

C++ sort는 평균/최악 모두 **O(N log N)**로 보는 게 표준(내부는 introsort)
→ O(N log N)

3) 정렬된 배열 1회 스캔하면서 최빈값 찾기

for i=1..N-1 한 번 도는 루프

각 반복에서 비교/증가/대입은 상수 시간
→ O(N)
T(N)=O(N)+O(NlogN)+O(N) => O(NlogN)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
저장하는 주요 데이터

vector<long long> v에 N개 저장

long long은 보통 8바이트(=64bit)

그래서 데이터만 보면 대략:

8×N bytes
8×N bytes

N=100,000이면:

8×100,000=800,000 bytes≈0.8 MB
8×100,000=800,000 bytes≈0.8 MB

추가로:

vector 자체의 관리 정보(포인터/size/capacity) 몇십 바이트 수준

루프 변수, 카운터 등은 상수 크기

즉 메모리는

M(N)=O(N)
M(N)=O(N)

참고: sort는 일반적으로 추가 메모리를 크게 쓰지 않는(in-place 성격) 정렬이라, 별도 O(N) 버퍼를 만드는 알고리즘이 아니라고 보면 된다(구현에 따라 재귀 스택 정도는 있음).

## cmp(Custom Comparator)
- 현재값과 다음값을 계속 비교

## 제출 전 체크(30초)
- sort를 사용했는가?
- 입력 정수 범위를 고려 하였는가?(long long)
- 가독성을 최대한 고려하였는가?
- 출력 포맷: "age name" + '\n'

## Postmortem(틀렸을 때만)
- 증상:
- 원인 1줄:
- 수정:
- 재발 방지:
2. v.reserve(N);
- 여기서 N이 int라면, int → size_t로 자동 변환이 일어납니다.
- 대부분의 경우 문제 없이 동작하지만, N이 음수일 경우 size_t는 부호 없는 정수(unsigned)이므로 큰 양수로 변환되어 버립니다.
→ 예: N = -1이면 size_t로 변환 시 매우 큰 값이 되어버림.
3. v.reserve(static_cast<size_t>(N));
- 여기서는 명시적으로 N을 size_t로 캐스팅합니다.
- 코드 읽는 사람에게 "이 값은 음수가 될 수 없고, 메모리 크기 용도로 쓰인다"는 의도를 더 명확히 전달합니다.
- 컴파일러 경고를 피하고, 타입 안정성을 높이는 효과가 있습니다.

