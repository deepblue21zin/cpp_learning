# BOJ 1302 - 베스트셀러

## REQ
- (1) 오늘 하루 동안 팔린 책의 제목이 입력으로 들어왔을 때, 가장 많이 팔린 책의 제목을 출력하는 프로그램을 작성
- (2) N개의 수중 가장 많은 수를 출력한다.
-  N (1 ≤ N ≤ 1000) 자연수
- 262보다 크거나 같고, 262보다 작거나 같다. 입력 정수
- 출력: 가장 많이 가지고 있는 정수 출력

## DS
- vector<Person> (age, name)

## Algo
- 입력받은 수를 크기순으로 나열한다.
    - 같은 수의 경우 입력받은 순서로 나열한다.
- 하나씩 읽었을때 같은수의 경우 cnt를 증가시키고, 전과 다른수가 나오면 cnt값을 previous_value[]에 stable_sort한 배열 값과 함께 저장하고 cnt를 0으로 초기화한다. 그후 다시 카운트를 시작하고 다른 수가 나오는 순간 그때cnt값이 previous_value보다 크면 업데이트하고 아니면 0으로 초기화한다.

    ## Complexity
    - Time: O(N×L)
    - Mem: O(N×L)
Time
1) 입력 및 해시 맵 삽입: O(N×L)

    unordered_map은 내부적으로 Hash Table을 사용합니다.

    데이터 삽입(freq[book]++)의 평균 시간 복잡도는 $O(1)$입니다.

    하지만 문자열을 키로 쓸 때는 문자열의 길이(L)만큼 해시 함수를 계산해야 하므로, 실제로는 $O(L)$이 걸립니다.

    이를 N번 반복하므로 이 단계는 **O(N×L)**입니다.

2) 최댓값 탐색 루프: O(N×L)

    freq에 담긴 모든 요소(최대 N개)를 한 번씩 순회합니다.

    word < max_word 비교 연산 역시 문자열의 길이 L에 비례합니다.

    따라서 이 루프도 **O(N×L)**입니다.
Mem
1) 데이터 저장: O(N×L)

    unordered_map에 최대 N개의 단어를 저장해야 합니다.

    각 단어의 길이를 고려하면 총 메모리는 **O(N×L)**을 차지합니다.

    문제의 제한(N=1,000, L=50)을 대입하면 약 50KB 내외로, 메모리 제한(128MB)에 비해 매우 널널합니다.

## cmp(Custom Comparator)
- 입력받은 문자열을 비교
- 입력 문자열 개수가 같은경우 먼저 입력받은 문자를 출력
- unordered_map<string, int> freq;

## 제출 전 체크(30초)
- 

## Postmortem(틀렸을 때만)
- 증상:글자수가 같은경우 빈도가 많은걸 출력함, 하지만 글자수가 차이나는 경우 빈도와 상관없이 글자수 긴걸 출력함.
- 원인 1줄: 배열로 받아서 길이가 문제가 생김
- 수정: unordered_map<string, int> freq; 로 수정
- 재발 방지:

2. 
- 증상 : 6 aaa bbb의 경우 b가 출력된다.
- 먼저 입력 받은걸 출력하게 만들어야 한다.
- 해결 : if(count > max_val || (count == max_val && word < max_word)){
            max_val = count;
            max_word = word;
        }   