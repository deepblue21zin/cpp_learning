# BOJ 2563 - 색종이

## Resource Budget (write first)
- 1 <= N <= 100
- 0 <= x, y <= 90  (색종이 10x10이 100x100 안에 들어가야 함)
Time: O(N * 10 * 10) + O(100 * 100)  // 칠하기 + 전체 카운트
RAM: grid[100][100] uint8_t = 10,000 bytes (≈ 9.8 KB) + 변수 몇 개
Type risk: NO (area <= 10,000 fits in int32)
Stack risk: YES if grid is local (특히 int로 잡으면 수십 KB) -> static/global 권장

## REQ
- 입력: 색종이 개수 N, 이후 N줄에 (x, y) (검은색 색종이의 왼쪽 아래 모서리 좌표)
- 처리: 100x100 흰 도화지에 10x10 검은색 색종이를 붙였을 때,
        겹치는 부분은 한 번만 계산하여 검은 영역의 넓이를 구한다.
- 출력: 검은 영역의 넓이(정수)

## Approach
1) 100x100 격자 grid를 0으로 초기화한다. (0=흰색, 1=검정)
2) 각 색종이 좌표 (x, y)에 대해:
   - r = x .. x+9, c = y .. y+9 범위를 grid[r][c] = 1로 칠한다.
   - 겹침은 덮어쓰기(1 유지)로 자동 처리된다.
3) grid 전체(0..99, 0..99)를 순회하며 값이 1인 칸 개수를 센다.
4) 센 개수를 출력한다.

## Data structure
- 고정 크기 2D 배열: uint8_t grid[100][100]
  - 범위가 작고 고정(100x100)이라 동적할당 불필요
  - 메모리 예측 가능(≈10KB), 임베디드 관점에서 안전

## Complexity
- Time: O(N*100 + 10,000)  // N<=100이므로 최악도 매우 작음
- Memory: O(1) (상수 크기 10KB)

## Edge cases
- 겹침: (0,0)과 (5,5) 같이 일부가 겹치는 경우 (중복 카운트 금지)
- 완전 겹침: 같은 좌표를 여러 번 입력 (결과는 100 유지)
- 경계: (90,90)처럼 끝에 붙는 경우도 10x10이 정확히 들어가야 함

## Tests
- tests.txt 참고 (예제/경계/반례)
- 추천 반례:
  - 2장 부분 겹침: (0,0), (5,5) => 100+100-25 = 175
  - 완전 겹침: (0,0) x N => 100
  - 경계: (90,90) => 100

## Postmortem
- (예) 칠할 때 r < x+10, c < y+10 조건을 잘못 써서 OOB 발생 -> 항상 min(…,100) 또는 입력 조건(0..90) 가정 명시